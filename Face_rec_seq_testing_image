#include "opencv2/opencv.hpp"
#include <fstream>
#include <opencv2/core/core.hpp>
#include <iostream>
#include <string>

using namespace cv;
using namespace std;

int main()
{
	size_t num_removed_eigenfaces=0; // =total_eigenfaces-desired_num_of_eigenfaces;

    FileStorage fs;
    fs.open("data_5_10.xml", FileStorage::READ);

    Mat mean_vec;
        fs["mean"] >> mean_vec;

     mean_vec=mean_vec.reshape(0,10304);

    Mat eigenvalues;
              fs["eigenvalues"] >> eigenvalues;
              //cout<<eigenvalues<<endl;

    Mat eigenvectors;
              fs["eigenvectors"] >> eigenvectors;

    Mat projections[50];
    int count=0;

    FileNode n = fs["projections"];
        for (FileNodeIterator current = n.begin(); current != n.end(); current++)
        {
            FileNode item = *current;
            item >> projections[count];
            projections[count]=projections[count].reshape(0,50);
            projections[count].pop_back(num_removed_eigenfaces);
            count++;
        }

    Mat labels;
            fs["labels"] >> labels;

   Mat testSample = imread("1.pgm",0);

   testSample=testSample.reshape(0,10304);
   testSample.convertTo(testSample,6);

   Mat sub_vec;

   sub_vec=testSample-mean_vec;

   Mat trans_eigenspace=eigenvectors.reshape(0,50);//transpose
   PCA eigenspace(eigenvectors,noArray(),CV_PCA_DATA_AS_COL);

   Mat test_weight;
   test_weight=trans_eigenspace*sub_vec;
   test_weight.pop_back(num_removed_eigenfaces);

  Scalar s[50];

   for(int j=0;j<50;j++)
   {
	   Mat diff=test_weight-projections[j];
	   pow(diff,2,diff);
	   s[j]=sum(diff);
	   sqrt(s[j],s[j]);
	   //cout<<s[j][0]<<endl;
   }

   Scalar min=s[0];
   int m;
   for(int k=0;k<50;k++)
   {
	 if(s[k][0]<min[0])
	{
		 min=s[k];
		 m=k;
	}
  }
//m++;
//int predicted=m/10;
   Mat predicted_mat=labels.col(m).clone();
   int predicted=predicted_mat.at<int>(0,0);

cout<<predicted<<endl;

fs.release();
        return (0);
}
